# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yKKMKBNgLovyZIg9KJEnti86DTZPGmu_
"""

#!/usr/bin/env python3
"""
Criteria Selection Dashboard - Streamlit Web Application
"""

import streamlit as st
import pandas as pd
import numpy as np
import openpyxl
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.utils import get_column_letter
import os
from datetime import datetime
import pyomo.environ as pyo
from pyomo.opt import SolverFactory, TerminationCondition
import re
from typing import Dict, List, Tuple, Any
import io

# ================================================================
# PAGE CONFIGURATION
# ================================================================
st.set_page_config(
    page_title="Criteria Selection Dashboard",
    page_icon="üéØ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
    <style>
    .main {padding: 2rem;}
    .stButton>button {width: 100%;}
    </style>
""", unsafe_allow_html=True)

# ================================================================
# EXCEL PROCESSOR CLASS
# ================================================================
class MCDMExcelProcessor:
    def __init__(self, excel_file):
        self.excel_file = pd.ExcelFile(excel_file)
        self.sheet_names = self.excel_file.sheet_names
        self.criteria = []
        self.criteria_ids = []
        self.criteria_names = []
        self.alternatives = []
        self.experts = []
        self.num_criteria = 0
        self.num_alternatives = 0
        self.num_experts = 0
        self.c_values = None
        self.o_values = None
        self.m_values = None
        self.s_values = None
        self.ce_values = None
        self.a_values = None
        self.cc_values = None
        self.r_mat = None
        self.below_criteria = {
            'completeness': [],
            'measurability': [],
            'cognitive_coherence': [],
            'alignment': [],
            'cost_effectiveness': [],
            'sensitivity': []
        }
        self.criterion_types = {}

    def extract_basic_info(self):
        criteria_found = False
        for sheet_name in self.sheet_names:
            if 'Step1' in sheet_name or 'Completeness' in sheet_name:
                df = pd.read_excel(self.excel_file, sheet_name=sheet_name)
                if 'Criterion ID' in df.columns and 'Criterion Name' in df.columns:
                    self.criteria_ids = df['Criterion ID'].dropna().tolist()
                    self.criteria_names = df['Criterion Name'].dropna().tolist()
                    self.criteria = self.criteria_ids if self.criteria_ids else self.criteria_names
                    criteria_found = True
                    break
                elif 'Criterion' in df.columns:
                    self.criteria = df['Criterion'].dropna().unique().tolist()
                    self.criteria_ids = self.criteria
                    self.criteria_names = self.criteria
                    criteria_found = True
                    break

        alternatives_found = False
        for sheet_name in self.sheet_names:
            if 'Step6' in sheet_name or 'Sensitivity' in sheet_name:
                df = pd.read_excel(self.excel_file, sheet_name=sheet_name, header=None)
                for idx, row in df.iterrows():
                    for col_idx, cell in enumerate(row):
                        if str(cell).strip() == 'Alternative':
                            alt_values = []
                            for next_idx in range(idx + 1, min(idx + 10, len(df))):
                                alt_value = df.iloc[next_idx, col_idx]
                                if pd.notna(alt_value) and str(alt_value).strip():
                                    if 'Expert' in str(alt_value) or 'Matrix' in str(alt_value):
                                        break
                                    alt_values.append(str(alt_value).strip())
                            if alt_values:
                                self.alternatives = alt_values
                                alternatives_found = True
                                break
                    if alternatives_found:
                        break
                if alternatives_found:
                    break

        expert_count = 0
        for sheet_name in self.sheet_names:
            if 'Step6' in sheet_name or 'Sensitivity' in sheet_name:
                df = pd.read_excel(self.excel_file, sheet_name=sheet_name, header=None)
                for idx, row in df.iterrows():
                    row_str = ' '.join(str(cell) for cell in row if pd.notna(cell))
                    if 'Expert' in row_str and ('Decision Matrix' in row_str or 'Matrix' in row_str):
                        expert_count += 1
                break

        self.num_experts = expert_count if expert_count > 0 else 3
        self.num_criteria = len(self.criteria)
        self.num_alternatives = len(self.alternatives)
        self.identify_criterion_types()

    def identify_criterion_types(self):
        cost_keywords = ['cost', 'emission', 'impact', 'time', 'requirement', 'risk', 'complexity']
        if self.criteria_names and len(self.criteria_names) == len(self.criteria_ids):
            for crit_id, crit_name in zip(self.criteria_ids, self.criteria_names):
                name_lower = crit_name.lower()
                is_cost = any(keyword in name_lower for keyword in cost_keywords)
                self.criterion_types[crit_id] = 'cost' if is_cost else 'benefit'
        else:
            for criterion in self.criteria:
                criterion_lower = criterion.lower()
                is_cost = any(keyword in criterion_lower for keyword in cost_keywords)
                self.criterion_types[criterion] = 'cost' if is_cost else 'benefit'

    def find_sheet_by_keyword(self, *keywords):
        for sheet_name in self.sheet_names:
            sheet_lower = sheet_name.lower()
            if all(keyword.lower() in sheet_lower for keyword in keywords):
                return sheet_name
        return None

    def process_all_sheets(self):
        self.extract_basic_info()
        self.process_step1_completeness()
        self.process_step2_objectivity()
        self.process_step3_measurability()
        self.process_step4_distinctiveness()
        self.process_step6_sensitivity()
        self.process_step7_cost_effectiveness()
        self.process_step8_alignment()
        self.process_step9_cognitive_coherence()
        return self.get_results()

    def process_step1_completeness(self):
        sheet_name = self.find_sheet_by_keyword('Step1', 'Completeness')
        if not sheet_name:
            return
        df = pd.read_excel(self.excel_file, sheet_name=sheet_name)
        if 'Average' in df.columns:
            self.c_values = df['Average'].dropna().values
        elif 'Avg' in df.columns:
            self.c_values = df['Avg'].dropna().values
        if 'Status' in df.columns:
            status_col = df['Status'].fillna('').astype(str)
            below_mask = status_col.str.lower() == 'below'
            if 'Criterion ID' in df.columns:
                self.below_criteria['completeness'] = df.loc[below_mask, 'Criterion ID'].tolist()

    def process_step2_objectivity(self):
        sheet_name = self.find_sheet_by_keyword('Step2', 'Objectivity')
        if not sheet_name:
            return
        df = pd.read_excel(self.excel_file, sheet_name=sheet_name)
        if 'Consensus' in df.columns:
            self.o_values = df['Consensus'].dropna().values
        elif 'Consensus Score' in df.columns:
            self.o_values = df['Consensus Score'].dropna().values

    def process_step3_measurability(self):
        sheet_name = self.find_sheet_by_keyword('Step3', 'Measurability')
        if not sheet_name:
            return
        df = pd.read_excel(self.excel_file, sheet_name=sheet_name)
        if 'Average' in df.columns:
            self.m_values = df['Average'].dropna().values
        elif 'Avg' in df.columns:
            self.m_values = df['Avg'].dropna().values
        if 'Status' in df.columns:
            status_col = df['Status'].fillna('').astype(str)
            below_mask = status_col.str.lower() == 'below'
            if 'Criterion ID' in df.columns:
                self.below_criteria['measurability'] = df.loc[below_mask, 'Criterion ID'].tolist()

    def process_step4_distinctiveness(self):
        sheet_name = self.find_sheet_by_keyword('Step4', 'Distinctiveness')
        if not sheet_name:
            return
        decision_matrices = self.read_decision_matrices(sheet_name)
        if decision_matrices:
            correlations = []
            for expert_name, matrix in decision_matrices.items():
                corr_matrix = matrix.corr()
                correlations.append(corr_matrix)
            if correlations:
                avg_correlation = sum(correlations) / len(correlations)
                self.r_mat = avg_correlation.abs().values

    def process_step6_sensitivity(self):
        sheet_name = self.find_sheet_by_keyword('Step6', 'Sensitivity')
        if not sheet_name:
            return
        decision_matrices = self.read_decision_matrices(sheet_name)
        if not decision_matrices:
            return
        normalized_matrices = {}
        for expert_name, matrix in decision_matrices.items():
            normalized_matrices[expert_name] = self.normalize_matrix(matrix)
        num_simulations = 1000
        num_criteria = len(self.criteria)
        random_weights = np.random.dirichlet(np.ones(num_criteria), num_simulations)
        sensitivity_results = {}
        for expert_name, norm_mat in normalized_matrices.items():
            elasticities = pd.DataFrame(index=norm_mat.columns, columns=range(num_simulations))
            for i, weights in enumerate(random_weights):
                scores = np.dot(norm_mat.values, weights)
                for j, criterion in enumerate(norm_mat.columns):
                    w = weights[j]
                    elasticity = (norm_mat[criterion] * w).sum() / scores.sum()
                    elasticities.loc[criterion, i] = elasticity
            sensitivity_results[expert_name] = elasticities.mean(axis=1)
        if sensitivity_results:
            average_elasticity = pd.DataFrame(sensitivity_results).mean(axis=1)
            self.s_values = average_elasticity.values
            threshold = 0.05
            for i, value in enumerate(self.s_values):
                if value < threshold:
                    if i < len(self.criteria):
                        criterion = self.criteria[i]
                        if criterion not in self.below_criteria['sensitivity']:
                            self.below_criteria['sensitivity'].append(criterion)

    def process_step7_cost_effectiveness(self):
        sheet_name = self.find_sheet_by_keyword('Step7', 'Cost')
        if not sheet_name:
            return
        df = pd.read_excel(self.excel_file, sheet_name=sheet_name)
        costs = np.zeros(self.num_criteria)
        expert_ratings = np.zeros((self.num_criteria, self.num_experts))
        crit_col = 'Criterion ID' if 'Criterion ID' in df.columns else 'Criterion'
        cost_col = None
        for col in df.columns:
            if 'Cost' in str(col) or 'Evaluation Cost' in str(col):
                cost_col = col
                break
        expert_cols = [col for col in df.columns if 'Expert' in str(col) or 'Rating' in str(col)]
        if crit_col and cost_col:
            crit_to_idx = {crit: i for i, crit in enumerate(self.criteria)}
            for _, row in df.iterrows():
                if pd.notna(row[crit_col]):
                    criterion = str(row[crit_col])
                    if criterion in crit_to_idx:
                        idx = crit_to_idx[criterion]
                        if pd.notna(row[cost_col]):
                            costs[idx] = float(row[cost_col])
                        for j, expert_col in enumerate(expert_cols[:self.num_experts]):
                            if pd.notna(row[expert_col]):
                                expert_ratings[idx, j] = float(row[expert_col])
        if np.any(costs > 0) and np.any(expert_ratings > 0):
            average_scores = np.mean(expert_ratings, axis=1)
            effectiveness_weights = np.ones(self.num_criteria)
            for i in range(self.num_criteria):
                if average_scores[i] > 0:
                    effectiveness_weights[i] = 1 - (average_scores[i] - 5) / 5
                    effectiveness_weights[i] = max(0.1, min(2.0, effectiveness_weights[i]))
            self.ce_values = costs * effectiveness_weights
        if 'Status' in df.columns:
            status_col = df['Status'].fillna('').astype(str)
            below_mask = status_col.str.lower() == 'below'
            if crit_col:
                self.below_criteria['cost_effectiveness'] = df.loc[below_mask, crit_col].tolist()

    def process_step8_alignment(self):
        sheet_name = self.find_sheet_by_keyword('Step8', 'Alignment')
        if not sheet_name:
            return
        df = pd.read_excel(self.excel_file, sheet_name=sheet_name)
        if 'Average' in df.columns:
            self.a_values = df['Average'].dropna().values
        elif 'Avg' in df.columns:
            self.a_values = df['Avg'].dropna().values
        if 'Status' in df.columns:
            status_col = df['Status'].fillna('').astype(str)
            below_mask = status_col.str.lower() == 'below'
            if 'Criterion ID' in df.columns:
                self.below_criteria['alignment'] = df.loc[below_mask, 'Criterion ID'].tolist()

    def process_step9_cognitive_coherence(self):
        sheet_name = self.find_sheet_by_keyword('Step9', 'Cognitive', 'Coherence')
        if not sheet_name:
            return
        df = pd.read_excel(self.excel_file, sheet_name=sheet_name)
        if 'Average' in df.columns:
            self.cc_values = df['Average'].dropna().values
        elif 'Avg' in df.columns:
            self.cc_values = df['Avg'].dropna().values
        if 'Status' in df.columns:
            status_col = df['Status'].fillna('').astype(str)
            below_mask = status_col.str.lower() == 'below'
            if 'Criterion ID' in df.columns:
                self.below_criteria['cognitive_coherence'] = df.loc[below_mask, 'Criterion ID'].tolist()

    def read_decision_matrices(self, sheet_name):
        df_full = pd.read_excel(self.excel_file, sheet_name=sheet_name, header=None)
        decision_matrices = {}
        expert_markers = []
        for idx, row in df_full.iterrows():
            row_str = ' '.join(str(cell) for cell in row if pd.notna(cell))
            if 'Expert' in row_str and ('Decision Matrix' in row_str or 'Matrix' in row_str):
                match = re.search(r'Expert\s*(\d+)', row_str)
                if match:
                    expert_num = int(match.group(1))
                    expert_markers.append((idx, f'Expert {expert_num}'))
        if expert_markers:
            for i, (start_row, expert_name) in enumerate(expert_markers):
                if i < len(expert_markers) - 1:
                    end_row = expert_markers[i + 1][0] - 1
                else:
                    end_row = start_row + 20
                try:
                    df_matrix = pd.read_excel(self.excel_file, sheet_name=sheet_name,
                                            skiprows=start_row + 1,
                                            nrows=min(end_row - start_row - 1, 10))
                    if not df_matrix.empty:
                        alt_col = None
                        for col in df_matrix.columns:
                            if 'Alternative' in str(col) or 'Option' in str(col):
                                alt_col = col
                                break
                        if alt_col is None and not df_matrix.columns[0].startswith('Unnamed'):
                            alt_col = df_matrix.columns[0]
                        if alt_col:
                            valid_alts = df_matrix[alt_col].dropna()
                            valid_alts = [alt for alt in valid_alts if
                                        isinstance(alt, str) and len(alt) > 5 and
                                        'Expert' not in alt and 'Matrix' not in alt]
                            if valid_alts:
                                criteria_cols = []
                                for col in df_matrix.columns:
                                    if col != alt_col and not str(col).startswith('Unnamed'):
                                        if col in self.criteria or col in self.criteria_ids or col in self.criteria_names:
                                            criteria_cols.append(col)
                                if not criteria_cols:
                                    criteria_cols = [col for col in df_matrix.columns
                                                   if col != alt_col and not str(col).startswith('Unnamed')]
                                if criteria_cols:
                                    matrix_data = df_matrix.loc[df_matrix[alt_col].isin(valid_alts), criteria_cols]
                                    matrix_data.index = valid_alts[:len(matrix_data)]
                                    for col in matrix_data.columns:
                                        matrix_data[col] = pd.to_numeric(matrix_data[col], errors='coerce')
                                    matrix_data = matrix_data.dropna(how='all').dropna(axis=1, how='all')
                                    if not matrix_data.empty:
                                        decision_matrices[expert_name] = matrix_data
                except Exception as e:
                    continue
        return decision_matrices

    def normalize_matrix(self, matrix):
        norm = matrix.copy()
        for col in matrix.columns:
            max_val = matrix[col].max()
            min_val = matrix[col].min()
            if max_val == min_val:
                norm[col] = 1.0
            elif self.criterion_types.get(col, 'benefit') == 'benefit':
                norm[col] = (matrix[col] - min_val) / (max_val - min_val)
            else:
                norm[col] = (max_val - matrix[col]) / (max_val - min_val)
        return norm

    def get_results(self):
        return {
            'criteria': self.criteria,
            'criteria_ids': self.criteria_ids,
            'criteria_names': self.criteria_names,
            'alternatives': self.alternatives,
            'num_criteria': self.num_criteria,
            'num_alternatives': self.num_alternatives,
            'num_experts': self.num_experts,
            'c_values': self.c_values,
            'o_values': self.o_values,
            'm_values': self.m_values,
            's_values': self.s_values,
            'ce_values': self.ce_values,
            'a_values': self.a_values,
            'cc_values': self.cc_values,
            'r_mat': self.r_mat,
            'below_criteria': self.below_criteria,
            'criterion_types': self.criterion_types
        }

# ================================================================
# TEMPLATE GENERATOR STUB (Simplified for now)
# ================================================================
def create_excel_template(config, thresholds):
    st.warning("Template generation feature coming soon! Use your Python desktop version for now.")
    return None

# ================================================================
# OPTIMIZATION MODEL
# ================================================================
def build_optimization_model_with_weights(results, weights):
    I = list(range(1, results['num_criteria'] + 1))
    w1, w2, w3, w4, w5, w6, w7, w8, w9 = [weights[f'w{i}'] for i in range(1, 10)]
    w5_minus = w5 / 2
    w5_plus = w5 / 2
    omega, zeta = 5, 9
    nI = len(I)

    c = {i: results['c_values'][i-1] if results['c_values'] is not None else 5.0 for i in I}
    m = {i: results['m_values'][i-1] if results['m_values'] is not None else 5.0 for i in I}
    s = {i: results['s_values'][i-1] if results['s_values'] is not None else 0.1 for i in I}
    ce = {i: results['ce_values'][i-1] if results['ce_values'] is not None else 1000.0 for i in I}
    a = {i: results['a_values'][i-1] if results['a_values'] is not None else 5.0 for i in I}
    cc = {i: results['cc_values'][i-1] if results['cc_values'] is not None else 5.0 for i in I}
    o = {i: results['o_values'][i-1] if results['o_values'] is not None else 0.5 for i in I}

    if results['r_mat'] is not None:
        r = {(i, j): results['r_mat'][i-1][j-1] for i in I for j in I if i < j}
    else:
        r = {(i, j): 0.0 for i in I for j in I if i < j}

    tot_c = sum(c.values())
    tot_m = sum(m.values())
    tot_a = sum(a.values())
    tot_cc = sum(cc.values())
    tot_s = sum(s.values())
    tot_ce = sum(ce.values())

    M = pyo.ConcreteModel()
    M.I = pyo.Set(initialize=I)
    M.x = pyo.Var(M.I, domain=pyo.Binary)

    excluded_indices = []
    for category, criteria_list in results['below_criteria'].items():
        for criterion in criteria_list:
            if criterion in results['criteria_ids']:
                idx = results['criteria_ids'].index(criterion) + 1
                excluded_indices.append(idx)
            elif criterion.startswith('C'):
                try:
                    idx = int(criterion[1:])
                    if 1 <= idx <= len(results['criteria_ids']):
                        excluded_indices.append(idx)
                except ValueError:
                    pass

    for idx in excluded_indices:
        M.x[idx].fix(0)

    M.N = pyo.Var(domain=pyo.NonNegativeIntegers, bounds=(5, 9))
    M.N_eq = pyo.Constraint(expr=M.N == sum(M.x[i] for i in M.I))
    M.d1_minus = pyo.Var(domain=pyo.NonNegativeReals)
    M.d1_plus = pyo.Var(domain=pyo.NonNegativeReals)
    M.d2_minus = pyo.Var(domain=pyo.NonNegativeReals)
    M.d2_plus = pyo.Var(domain=pyo.NonNegativeReals)
    M.par_low = pyo.Constraint(expr=M.N + M.d1_minus - M.d1_plus == omega)
    M.par_high = pyo.Constraint(expr=M.N + M.d2_minus - M.d2_plus == zeta)

    pairs = [(i, j) for i in I for j in I if i < j]
    M.pairs = pyo.Set(initialize=pairs, dimen=2)
    M.h = pyo.Var(M.I, M.I, domain=pyo.Binary)
    M.h1 = pyo.Constraint(M.pairs, rule=lambda M,i,j: M.h[i,j] >= M.x[i] + M.x[j] - 1)
    M.h2 = pyo.Constraint(M.pairs, rule=lambda M,i,j: M.h[i,j] <= M.x[i])
    M.h3 = pyo.Constraint(M.pairs, rule=lambda M,i,j: M.h[i,j] <= M.x[j])

    norm_benefit = {i: (w1*c[i]/tot_c) + (w3*m[i]/tot_m) + (w8*a[i]/tot_a) + (w9*cc[i]/tot_cc) for i in I}
    sens_term = (w6 / tot_s) * sum(s[i]*M.x[i] for i in M.I)
    ce_comp = {i: (tot_ce - ce[i]) / tot_ce for i in I}
    ce_term = w7 * sum(ce_comp[i]*M.x[i] for i in M.I)
    rho = (1/nI) * sum(o[i]*M.x[i] for i in M.I)
    dist_pen = w4 * (sum(r[i,j]*M.h[i,j] for (i,j) in M.pairs) / (nI*(nI-1)/2))
    par_pen = (w5_minus*M.d1_minus + w5_plus*M.d2_plus) / nI

    M.obj = pyo.Objective(
        expr = sum(norm_benefit[i]*M.x[i] for i in M.I) + w2*rho + sens_term + ce_term - dist_pen - par_pen,
        sense=pyo.maximize
    )

    solver = None
    for name in ("cbc", "highs", "glpk"):
        s = SolverFactory(name)
        if s.available(False):
            solver = s
            break

    if solver is None:
        return None, "No MILP solver found"

    result = solver.solve(M, tee=False)

    if result.solver.termination_condition == TerminationCondition.optimal:
        binary = [int(round(pyo.value(M.x[i]))) for i in I]
        selected = [results['criteria_ids'][i-1] for i in I if int(round(pyo.value(M.x[i]))) == 1]
        not_selected = [results['criteria_ids'][i-1] for i in I if int(round(pyo.value(M.x[i]))) == 0]
        obj_value = pyo.value(M.obj)
        n_value = pyo.value(M.N)
        rho_value = pyo.value((1/len(I))*sum(o[i]*M.x[i] for i in M.I))

        return {
            'status': 'optimal',
            'selected': selected,
            'not_selected': not_selected,
            'binary': binary,
            'n_value': n_value,
            'rho_value': rho_value,
            'obj_value': obj_value,
            'excluded': [results['criteria_ids'][idx-1] for idx in excluded_indices]
        }, None
    else:
        return None, "No optimal solution found"

# ================================================================
# STREAMLIT UI
# ================================================================
def main():
    st.title("üéØ Criteria Selection Dashboard")
    st.markdown("*Multi-Criteria Decision Making - Web Application*")
    st.markdown("---")

    if 'results' not in st.session_state:
        st.session_state.results = None
    if 'opt_result' not in st.session_state:
        st.session_state.opt_result = None

    st.sidebar.title("Navigation")
    page = st.sidebar.radio("Go to", ["üìä Excel Processor", "‚öôÔ∏è Optimization", "üìà Results"])

    # EXCEL PROCESSOR
    if page == "üìä Excel Processor":
        st.header("üìä Excel Processor")
        st.markdown("Upload your completed Excel template for processing")

        uploaded_file = st.file_uploader("Choose an Excel file", type=['xlsx'])

        if uploaded_file is not None:
            if st.button("üîÑ Process Excel File", use_container_width=True):
                with st.spinner("Processing..."):
                    try:
                        processor = MCDMExcelProcessor(uploaded_file)
                        results = processor.process_all_sheets()
                        st.session_state.results = results

                        st.success("‚úÖ Excel file processed successfully!")

                        col1, col2, col3 = st.columns(3)
                        col1.metric("Criteria", results['num_criteria'])
                        col2.metric("Alternatives", results['num_alternatives'])
                        col3.metric("Experts", results['num_experts'])

                        st.subheader("Data Arrays Extracted")
                        arrays = [
                            ('Completeness', results['c_values']),
                            ('Objectivity', results['o_values']),
                            ('Measurability', results['m_values']),
                            ('Sensitivity', results['s_values']),
                            ('Cost-effectiveness', results['ce_values']),
                            ('Alignment', results['a_values']),
                            ('Cognitive Coherence', results['cc_values']),
                        ]

                        for name, arr in arrays:
                            if arr is not None:
                                st.write(f"‚úì **{name}**: {len(arr)} values")
                            else:
                                st.write(f"‚úó **{name}**: Not found (will use defaults)")

                        if results['below_criteria']:
                            st.subheader("Criteria Below Thresholds")
                            for category, criteria in results['below_criteria'].items():
                                if criteria:
                                    st.write(f"‚Ä¢ **{category}**: {', '.join(criteria)}")

                    except Exception as e:
                        st.error(f"Error: {str(e)}")

        if st.session_state.results is None:
            st.info("üëÜ Upload an Excel file to get started")

    # OPTIMIZATION
    elif page == "‚öôÔ∏è Optimization":
        st.header("‚öôÔ∏è Optimization")

        if st.session_state.results is None:
            st.warning("‚ö†Ô∏è Please process an Excel file first!")
            return

        results = st.session_state.results
        st.info(f"üìä Data loaded: {results['num_criteria']} criteria, {results['num_alternatives']} alternatives, {results['num_experts']} experts")

        st.subheader("‚öñÔ∏è Weight Configuration")

        preset = st.selectbox("Choose a preset:", ["Equal", "Quality Focus", "Cost Focus", "Balance"])

        presets = {
            "Equal": [1/9] * 9,
            "Quality Focus": [0.15, 0.05, 0.15, 0.10, 0.10, 0.10, 0.05, 0.15, 0.15],
            "Cost Focus": [0.08, 0.10, 0.08, 0.08, 0.15, 0.08, 0.25, 0.09, 0.09],
            "Balance": [0.12, 0.08, 0.11, 0.09, 0.12, 0.10, 0.11, 0.13, 0.14]
        }

        default_weights = presets[preset]

        col1, col2, col3 = st.columns(3)

        with col1:
            w1 = st.number_input("Completeness (w1)", value=default_weights[0], format="%.3f")
            w2 = st.number_input("Objectivity (w2)", value=default_weights[1], format="%.3f")
            w3 = st.number_input("Measurability (w3)", value=default_weights[2], format="%.3f")

        with col2:
            w4 = st.number_input("Distinctiveness (w4)", value=default_weights[3], format="%.3f")
            w5 = st.number_input("Parsimony (w5)", value=default_weights[4], format="%.3f")
            w6 = st.number_input("Sensitivity (w6)", value=default_weights[5], format="%.3f")

        with col3:
            w7 = st.number_input("Cost-effectiveness (w7)", value=default_weights[6], format="%.3f")
            w8 = st.number_input("Alignment (w8)", value=default_weights[7], format="%.3f")
            w9 = st.number_input("Cognitive Coherence (w9)", value=default_weights[8], format="%.3f")

        total = w1 + w2 + w3 + w4 + w5 + w6 + w7 + w8 + w9

        if abs(total - 1.0) < 0.001:
            st.success(f"‚úÖ Sum: {total:.3f}")
        else:
            st.error(f"‚ùå Sum: {total:.3f} (must equal 1.0)")

        if st.button("üöÄ Run Optimization", use_container_width=True):
            if abs(total - 1.0) >= 0.001:
                st.error("‚ö†Ô∏è Weights must sum to 1.0")
                return

            with st.spinner("Running optimization..."):
                try:
                    weights = {'w1': w1, 'w2': w2, 'w3': w3, 'w4': w4, 'w5': w5, 'w6': w6, 'w7': w7, 'w8': w8, 'w9': w9}
                    opt_result, error = build_optimization_model_with_weights(results, weights)

                    if error:
                        st.error(f"Optimization failed: {error}")
                        return

                    st.session_state.opt_result = opt_result
                    st.success("‚úÖ Optimization completed successfully!")

                    col1, col2, col3 = st.columns(3)
                    col1.metric("Status", opt_result['status'].upper())
                    col2.metric("Selected Criteria", int(opt_result['n_value']))
                    col3.metric("Objective Value", f"{opt_result['obj_value']:.4f}")

                    st.subheader("‚úÖ Selected Criteria")
                    for i, crit in enumerate(opt_result['selected'], 1):
                        idx = results['criteria_ids'].index(crit)
                        if idx < len(results['criteria_names']):
                            name = results['criteria_names'][idx]
                            st.write(f"{i}. **{crit}**: {name}")

                    st.subheader("‚ùå Not Selected")
                    for crit in opt_result['not_selected']:
                        idx = results['criteria_ids'].index(crit)
                        reason = "Below threshold" if crit in opt_result['excluded'] else "Not optimal"
                        if idx < len(results['criteria_names']):
                            name = results['criteria_names'][idx]
                            st.write(f"‚Ä¢ **{crit}**: {name} ({reason})")

                except Exception as e:
                    st.error(f"Error: {str(e)}")

    # RESULTS
    elif page == "üìà Results":
        st.header("üìà Results Summary")

        if st.session_state.results is None or st.session_state.opt_result is None:
            st.warning("‚ö†Ô∏è Please process data and run optimization first!")
            return

        results = st.session_state.results
        opt_result = st.session_state.opt_result

        report = f"""============================================================
CRITERIA SELECTION DASHBOARD - COMPLETE RESULTS SUMMARY
============================================================

üìä DATA SUMMARY
----------------------------------------
Total Criteria Evaluated: {results['num_criteria']}
Total Alternatives: {results['num_alternatives']}
Number of Experts: {results['num_experts']}

üéØ OPTIMIZATION RESULTS
----------------------------------------
Optimization Status: {opt_result['status'].upper()}
Objective Function Value: {opt_result['obj_value']:.6f}
Selected Criteria Count: {int(opt_result['n_value'])}
Objectivity Ratio: {opt_result['rho_value']:.4f}

‚úÖ SELECTED CRITERIA
----------------------------------------
"""

        for i, crit in enumerate(opt_result['selected'], 1):
            idx = results['criteria_ids'].index(crit)
            if idx < len(results['criteria_names']):
                name = results['criteria_names'][idx]
                report += f"{i}. {crit}: {name}\n"

        report += "\n‚ùå EXCLUDED/NOT SELECTED CRITERIA\n"
        report += "-" * 40 + "\n"

        for crit in opt_result['not_selected']:
            idx = results['criteria_ids'].index(crit)
            reason = "Below threshold" if crit in opt_result['excluded'] else "Not optimal"
            if idx < len(results['criteria_names']):
                name = results['criteria_names'][idx]
                report += f"‚Ä¢ {crit}: {name} ({reason})\n"

        selected_indices = [i-1 for i, val in enumerate(opt_result['binary']) if val == 1]

        if selected_indices:
            st.subheader("üìà Performance Metrics")
            col1, col2, col3, col4 = st.columns(4)

            if results['c_values'] is not None:
                avg_completeness = np.mean([results['c_values'][i] for i in selected_indices])
                col1.metric("Avg Completeness", f"{avg_completeness:.2f}/10")

            if results['m_values'] is not None:
                avg_measurability = np.mean([results['m_values'][i] for i in selected_indices])
                col2.metric("Avg Measurability", f"{avg_measurability:.2f}/10")

            if results['a_values'] is not None:
                avg_alignment = np.mean([results['a_values'][i] for i in selected_indices])
                col3.metric("Avg Alignment", f"{avg_alignment:.2f}/10")

            if results['cc_values'] is not None:
                avg_cognitive = np.mean([results['cc_values'][i] for i in selected_indices])
                col4.metric("Avg Cognitive", f"{avg_cognitive:.2f}/10")

        st.text_area("Full Report", report, height=400)

        st.download_button(
            label="üìÑ Download Report",
            data=report,
            file_name=f"MCDM_Report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
            mime="text/plain",
            use_container_width=True
        )

if __name__ == "__main__":
    main()